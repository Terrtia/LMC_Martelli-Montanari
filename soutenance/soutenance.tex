\documentclass[10pt,a4paper]{report}

\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{lipsum}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage[dvipsnames]{xcolor}
\usepackage{setspace}

\hypersetup{
	colorlinks,
	urlcolor=black
	filecolor=black,
	linkcolor=black,
	citecolor=black,
}

\definecolor{mygray}{RGB}{240,240,240}

\lstset{
	language=Prolog,
	basicstyle=\ttfamily\small,
	identifierstyle=\color{Cerulean},
	numberstyle=\color{green},
	keywordstyle=\color{blue},
	commentstyle=\it\color{green},
	stringstyle=\color{black!60},
	columns=flexible,
	tabsize=4,
	extendedchars=true,
	showspaces=false,
	showstringspaces=false,
	numbers=left,
	numberstyle=\small,
	breaklines=true,
	breakautoindent=true,
	captionpos=b,
	backgroundcolor=\color{mygray},
	captionpos = b 
}

\newcommand{\HRule}{\rule{\linewidth}{2mm}}
\newsavebox{\BBbox}
\newenvironment{DDbox}[1]{
	\begin{lrbox}{\BBbox}\begin{minipage}{\linewidth}}
		{\end{minipage}\end{lrbox}\noindent\colorbox{mygray}{\usebox{\BBbox}} \\
	[.5cm]}

\fancypagestyle{plain}{
	\fancyhf{}
	\fancyhead[L]{Soutenance}
	\fancyhead[R]{\ifnum\value{part}>0 \partname\ \thepart \fi}
	\renewcommand{\headrulewidth}{0.4pt}
	\fancyfoot[L]{Aurélien Thirion et Nicolas Blin}
	\fancyfoot[C]{\thepage}
	\fancyfoot[R]{\today}
	\renewcommand{\footrulewidth}{0.4pt}
}


\geometry{
	a4paper,
	total={210mm,297mm},
	left=20mm,
	right=20mm,
	top=20mm,
	bottom=20mm,
}

\begin{document}
\begin{titlepage}
    \begin{center}
      ~\\[4cm]
      \textsc{\huge Université de Lorraine}\\[1.0cm]
      \includegraphics{univr.jpg}\\[0.5cm]
      \textsc{\Large Faculté de Science et Technologie}\\[0.5cm]
      \textsc{\Large M1 Informatique}\\[1cm]
      \HRule \\[0.4cm]
      { \huge \bfseries Martelli Montanari \\[0.4cm] }
      \HRule \\[1cm]
     \textsc{\LARGE Algorithme d'unification \\ ~ \\ Projet de LMC }\\[4cm]
	\emph{Auteurs:}\\
	Aurélien \textsc{Thirion} \\
	Nicolas \textsc{Blin}\\
      \vfill
      {\large \today}
    \end{center}
  \end{titlepage}








\chapter*{Introduction}
Nous avons voulu, dans ce projet, essayer d'être le plus clair et simple possible en
disposant dans différents fichiers le code source de notre programme. Ainsi dans le code
principal, il y a le minimum de ligne pour comprendre réellement de processus de
l'unification de Martelli-Montanari. Notre code principal se situe dans \textbf{main.pl}, des
prédicats sont appelés lors du processus dans les fichiers suivants : \textbf{operateur.pl} ,
\textbf{predicatsRelais.pl} et \textbf{reglesTest.pl}.\\[1cm]

\begin{center}
\textbf{operateur.pl}\\
Contient l'opérateur \textbf{?=} et le code pour le echo contenu dans le mail.\\[1cm]
\textbf{predicatsRelais.pl}\\
Fonction de décomposition d'une équation E pour obtenir la partie gauche de
l'opérateur \textbf{?=} et la partie droite.\\[1cm]
\textbf{reglesTest.pl}\\
Toutes les conditions nécessaire pour appliquer la réduction (prédicat regle(E, R)).\\[1cm]
\end{center}





\chapter*{Question 1}
\paragraph{Mise en place pour l'unification} ~\\
On peut voir ici les instructions pour l'ouverture des différents fichiers.
\begin{lstlisting}[caption ={Ouverture des fichiers dans $main.pl$}]
:-
	[operateurs],
	[predicatsRelais],
	[reglesTest].
\end{lstlisting} ~\\
Un exemple du prédicat regle(E,R) dans le code.
\begin{lstlisting}[caption ={regle dans le fichier $main.pl$}]
regle(E,rename)
\end{lstlisting} ~\\
Qui va appeler le prédicat dans le fichier \textbf{reglesTest.pl}. Ici on va séparer l'équation E en les termes X et T. Il va ensuite vérifier l'applicabilité de la règle $rename$.
\begin{lstlisting}[caption ={regle dans le fichier $reglesTest.pl$}]
regle(E, rename):-
	splitEquation(E,X,T),
	var(T),
	var(X).
\end{lstlisting} ~\\
Qui va appeler le prédicat dans le fichier \textbf{predicatsRelais.pl}. On récupère la partie gauche et droite de \textbf{?=} pour le mettre dans X et T respectivement.
\begin{lstlisting}[caption ={splitEquation dans le fichier $predicatsRelais.pl$}]
splitEquation(E,X,T):-
	arg(1,E,L),
	arg(2,E,R),
	X = L,
	T = R.
\end{lstlisting}

\paragraph{Occur check} ~\\
Le prédicat $occur_check$ a été assez simple à mettre en oeuvre. Il sera chargé de vérifier si V apparaît dans le terme composé T.
\begin{lstlisting}[caption ={occur\_check dans $main.pl$}]
occur_check(V,T):-
	compound(T),
	var(V),
	contains_var(V,T).
\end{lstlisting}

\paragraph{Reduit} ~\\
Voici un exemple de $reduit$ qui se charge d'appliquer la règle rename.
\begin{lstlisting}[caption ={reduit dans $main.pl$}]
reduit(rename, E, P, Q):-
	splitEquation(E,X,T),
	X = T,
	P = [_|Q].
\end{lstlisting}





\chapter*{Question 2}
\paragraph{Stratégies} ~\\
On s'intéresse désormais à la rapidité de l'exécution de l'algorithme d'unification.
Pour cela, on vas mettre en place plusieurs strarégies.
\newline
La Première stratégie consiste à choisir la première équation de la liste d'équations et d'essayer de lui appliquer une régle. Cette Stratégie correspond à la méthode de résolution qui à etait mise en place dans la question 1. Elle est définit par le prédicat suivant :
\begin{lstlisting}[caption ={Stratégie choix premier dans $main.pl$}]
% unification choix premier
unifie(P, choix_premier) :- 
	choix_premier(P, _, _, _),
	!.
	
	choix_premier(P, _, _, _) :- 
	unifie(P, regle),
	!.
\end{lstlisting} ~\\

La Deuxième stratégie consiste à appliquer les régles de transformation dans un certaine ordre. On cherche à appliquer certaines régles en priorité par rapport à d'autres. On essaie ainsi d'appliquer des régles sur l'ensemble du système d'équations avant d'en essayer d'autres. En d'autres termes, on essaie de trouver dans le systèmes d'équations une équation ou l'on peut appliquer notre régle au lieu de chercher une régle à appliquer à une équation.
\newline
On définit la priorité dans laquelle appliquer les régles comme suit:

\begin{enumerate}
  \item Clash, Check
  \item Rename, Simplify
  \item Orient
  \item Decompose
  \item Expand
\end{enumerate}
Par exemple, appliquer les régles Clash et Check en priorité permet de stopper l'éxécution plus rapidement si le système d'équation n'est pas unifiable.



\begin{lstlisting}[caption ={Stratégie choix pondere dans $main.pl$ avec les régles de poids 1}]
% unification choix pondere
unifie(P, choix_pondere) :-
	choix_pondere(P, P, _, 1),
	!.
	
%%%% clash, check

%clash
choix_pondere(_, [Head|_], _, 1):-
	regle(Head , clash),
	!,
 	reduit(clash, Head, P, _),
	!.

%check
choix_pondere(_, [Head|_], _, 1):-
	regle(Head, check),
	!,
	reduit(check, Head, P, _),
	!.

% regles non applicables dans le systeme d'equations
choix_pondere(P, [Head|Tail], _, 1):-
	\+regle(Head, clash),
	\+regle(Head, check),
	!,
	choix_pondere(P, Tail, _, 1),		% on essaye d'appliquer les transformations de niveau 1
	!.									% sur l'equation suivante

\end{lstlisting}

\begin{lstlisting}[caption ={Stratégie choix pondere dans $main.pl$, passage aux régles de poids 1 }]
choix_pondere(P, [], _, 2):-
	choix_pondere(P, P, _, 2),
	!.
\end{lstlisting}~\\



La Troisième stratégie consiste à sélectionner une équation au hasard dans le système d'èquations. On tente ensuite d'appliquer toutes les transformations sur cette équation.

\begin{lstlisting}[caption ={Stratégie choix aléatoire dans $main.pl$}]
%unification choix aleatoire
unifie(P, choix_aleatoire) :-
	choix_equation_aleatoire(P,_,_,_),
	!.
	
choix_equation_aleatoire([],_,_,_):- !.

choix_equation_aleatoire(P,_,_,_):-
	random_member(E, P), 						% on choisit aleatoirement une equation
	deleteEquation(P, E, ListTemp),				 % on supprime cette equation de la liste
	reduit_random([E|ListTemp], E, Q, regle),% on essaie d'appliquer les transformations E, nouvelle liste = Q
	choix_equation_aleatoire(Q,_,_,_).

reduit_random(ListTemp2, E, Q, regle) :- regle(E, rename), !, reduit(rename, E, ListTemp2, Q).
reduit_random(ListTemp2, E, Q, regle) :- regle(E, simplify), !, reduit(simplify, E, ListTemp2, Q).
reduit_random(ListTemp2, E, Q, regle) :- regle(E, expand), !, reduit(expand, E, ListTemp2, Q).
reduit_random(ListTemp2, E, Q, regle) :- regle(E, check), !, reduit(check, E, ListTemp2, Q).
reduit_random(ListTemp2, E, Q, regle) :- regle(E, orient), !, reduit(orient, E, ListTemp2, Q).
reduit_random(ListTemp2, E, Q, regle) :- regle(E, decompose), !, reduit(decompose, E, ListTemp2, Q).
reduit_random(ListTemp2, E, Q, regle) :- regle(E, clash), !, reduit(clash, E, ListTemp2, Q).
\end{lstlisting}~\\

\paragraph{Comparaison des Stratégies:} ~\\

Grace à ces exemples, on peut constater que le choix pondere permet de remarquer rapidement si une unification est possible ou non:

\begin{lstlisting}[caption ={Stratégie choix premier dans $main.pl$}]
?- trace_unif([c ?= Z, E?= Z, f(X,Y) ?= f(U,V,W)], choix_premier).
	system: [c?=_G1732,_G1737?=_G1732,f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)]
	orient: c?=_G1732
	system: [_G1732?=c,_G1737?=_G1732,f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)]
	simplify: _G1732?=c
	system: [_G1737?=c,f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)]
	simplify: _G1737?=c
	system: [f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)]
	clash: f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)
	[c?=_G1732,_G1737?=_G1732,f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)]
	No

\end{lstlisting}

\begin{lstlisting}[caption ={Stratégie choix pondere dans $main.pl$}]
?- trace_unif([c ?= Z, E?= Z, f(X,Y) ?= f(U,V,W)], choix_pondere).
	system: [c?=_G1732,_G1737?=_G1732,f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)]
	clash: f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)
	[c?=_G1732,_G1737?=_G1732,f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)]
	No
\end{lstlisting}

La Troisième stratégie permet en général de faire mieux que la stratégie choix premier:

\begin{lstlisting}[caption ={Stratégie choix pondere dans $main.pl$}]
?- trace_unif([c ?= Z, E?= Z, f(X,Y) ?= f(U,V,W)], choix_aleatoire).
	system: [f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748),c?=_G1732,_G1737?=_G1732]
	clash: f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)
	[c?=_G1732,_G1737?=_G1732,f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)]
	No

?- trace_unif([c ?= Z, E?= Z, f(X,Y) ?= f(U,V,W)], choix_aleatoire).
	system: [c?=_G1732,_G1737?=_G1732,f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)]
	orient: c?=_G1732
	system: [_G1737?=_G1732,_G1732?=c,f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)]
	rename: _G1737?=_G1732
	system: [_G1732?=c,f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)]
	simplify: _G1732?=c
	system: [f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)]
	clash: f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)
	[c?=_G1732,_G1737?=_G1732,f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)]
	No

?- trace_unif([c ?= Z, E?= Z, f(X,Y) ?= f(U,V,W)], choix_aleatoire).
	system: [_G1737?=_G1732,c?=_G1732,f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)]
	rename: _G1737?=_G1732
	system: [f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748),c?=_G1732]
	clash: f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)
	[c?=_G1732,_G1737?=_G1732,f(_G1743,_G1744)?=f(_G1746,_G1747,_G1748)]
	No

\end{lstlisting}

\mbox{}
\newpage
\chapter*{Question 3}
\paragraph{Dans le main} ~\\
Pour le prédicat $unif$, il s'agit simplement de désativer le echo puis d'appeler le prédicat $unifie$.
\begin{lstlisting}[caption ={unif dans $main.pl$}]
unif(P,S) :-
	clr_echo,
	unifie(P,S).
\end{lstlisting} ~\\
Pour le prédicat $trace\_unif$, il faut activer le echo en précisant que si l'unification marche il y aura affiché un "Yes" ou un "No" dans le cas contraire.
\begin{lstlisting}[caption ={trace\_unif dans $main.pl$}]
trace_unif(P,S) :-
	set_echo,
	(unifie(P,S),
	 echo('\tYes'),
	 !;
	 echo('\t'),
	 echo(P),
	 echo('\n'),
	 echo('\tNo')).
\end{lstlisting} ~\\
Une fois que ces prédcats sont fait, il suffit de mettre les echo dans le code qui sera commun aux différentes stratégies. Ainsi nous aurons par exemple dans le prédicat $reduit$ :
\begin{lstlisting}[caption ={Les echos dans $main.pl$}]
reduit(rename, E, P, Q):-
	echo('\tsystem: '),echo(P),nl,
	echo('\trename: '),echo(E),nl,
	splitEquation(E,X,T),
	X = T,
	P = [_|Q].
\end{lstlisting} ~\\




\mbox{}
\newpage
\chapter*{Tests}
\paragraph{Tests vus en cours} ~\\
On a décidé de présenter une liste de tests présents dans le cours pour illustrer la résolution de l'algorithme implanté.\\
(Un exemple qui devrait réussir)
\begin{lstlisting}[caption ={Des tests de cours}]
?- trace_unif([f(X,a) ?= f(g(Y),Y)],choix_pondere).
	system: [f(_G201,a)?=f(g(_G204),_G204)]
	decompose: f(_G201,a)?=f(g(_G204),_G204)
	system: [a?=_G204,_G201?=g(_G204)]
	orient: a?=_G204
	system: [_G204?=a,_G201?=g(_G204)]
	simplify: _G204?=a
	system: [_G201?=g(a)]
	expand: _G201?=g(a)
	Yes
X = g(a),
Y = a.
\end{lstlisting} ~\\

(Un exemple qui devrait échouer)
\begin{lstlisting}[caption ={Des tests de cours}]
?- trace_unif([f(b,a) ?= f(g(Y),Y)],choix_pondere).
	system: [f(b,a)?=f(g(_G204),_G204)]
	decompose: f(b,a)?=f(g(_G204),_G204)
	system: [a?=_G204,b?=g(_G204)]
	orient: a?=_G204
	system: [_G204?=a,b?=g(_G204)]
	simplify: _G204?=a
        [f(b,a)?=f(g(_G204),_G204)]
	No
\end{lstlisting} ~\\

(Un exemple qui devrait échouer)
\begin{lstlisting}[caption ={Des tests de cours}]
?- trace_unif([f(X,X) ?= f(g(Y),Y)],choix_pondere).
	system: [f(_G201,_G201)?=f(g(_G204),_G204)]
	decompose: f(_G201,_G201)?=f(g(_G204),_G204)
	system: [_G201?=_G204,_G201?=g(_G204)]
	rename: _G201?=_G204
        [f(_G1,_G1)?=f(g(_G2),_G2)]
	No
\end{lstlisting} ~\\

(Un exemple qui devrait réussir)
\begin{lstlisting}[caption ={Des tests de cours}]
?- trace_unif([f(X,Y) ?= f(Y,X)],choix_pondere).
	system: [f(_G201,_G202)?=f(_G202,_G201)]
	decompose: f(_G201,_G202)?=f(_G202,_G201)
	system: [_G201?=_G202,_G202?=_G201]
	rename: _G201?=_G202
	system: [_G201?=_G201]
	rename: _G201?=_G201
	Yes
X = Y.
\end{lstlisting} ~\\

(Un exemple qui devrait échouer)
\begin{lstlisting}[caption ={Des tests de cours}]
?- trace_unif([f(X,Y) ?= f(U,V,W)],choix_pondere).
        [f(_G201,_G202)?=f(_G204,_G205,_G206)]
	No
\end{lstlisting} ~\\







\mbox{}
\newpage
\chapter*{Code source}
\paragraph{Dans operateurs} ~\\
\begin{lstlisting}[caption ={$operateurs.pl$}]
:-
	op(20,xfy,?=).

% Predicats d'affichage fournis

% set_echo: ce predicat active l'affichage par le predicat echo
set_echo :-
	assert(echo_on).

% clr_echo: ce predicat inhibe l'affichage par le predicat echo
clr_echo :-
	retractall(echo_on).

% echo(T): si le flag echo_on est positionne, echo(T) affiche le terme T
%          sinon, echo(T) reussit simplement en ne faisant rien.

echo(T) :-
	echo_on,
	!,
	write(T).

echo(_).
\end{lstlisting}

\paragraph{Dans predicatsRelais} ~\\
\begin{lstlisting}[caption ={$predicatsRelais.pl$}]
splitEquation(E,X,T):-
	arg(1,E,L),
	arg(2,E,R),
	X = L,
	T = R.
\end{lstlisting}

\paragraph{Dans reglesTest} ~\\
\begin{lstlisting}[caption ={$reglesTest.pl$}]
regle(E, rename):-
	splitEquation(E,X,T),
	var(T),
	var(X).

regle(E, simplify):-
	splitEquation(E,X,T),
	atomic(T),
	var(X).

regle(E, orient):-
	splitEquation(E,T,X),
	var(X),
	nonvar(T).

regle(E, check):-
	splitEquation(E,X,T),
	var(X),
	not(X==T),
	occur_check(X,T).

regle(E, expand):-
	splitEquation(E,X,T),
	var(X),
	not(atomic(T)),
	nonvar(T),
	not(occur_check(X,T)).

regle(E, decompose):-
	splitEquation(E,S,T),
	compound(S),
	compound(T),
	functor(S,NameS,ArityS),
	functor(T,NameT,ArityT),
	NameS == NameT,
	ArityS == ArityT.

regle(S ?= T, clash):-
	compound(S),
	compound(T),
	functor(S,NameS,ArityS),
	functor(T,NameT,ArityT),
	\+((NameS == NameT, ArityS == ArityT)).
\end{lstlisting}

\paragraph{Dans le main} ~\\
\begin{lstlisting}[caption ={$main.pl$}]
% Ajout d'autres fichiers pour simplier le code principal
:-
	[operateurs], % ?= , echo
	[predicatsRelais], % splitEquation
	[reglesTest]. % test de validite sur chaque regle

% Predicats

% Occur_check
occur_check(V,T):-
	compound(T),
	var(V),
	contains_var(V,T).

% unif
unif(P,S) :-
	clr_echo,
	unifie(P,S).

% trace_unif
trace_unif(P,S) :-
	set_echo,
	(unifie(P,S),
	 echo('\tYes'),
	 !;
	 echo('\t'),
	 echo(P),
	 echo('\n'),
	 echo('\tNo')).

% unification
unifie([], _) :- !.
unifie([]) :- !.

% unification choix premier
unifie(P, choix_premier) :- 
	choix_premier(P, _, _, _),
	!.

%unification choix pondere
unifie(P, choix_pondere) :-
	choix_pondere(P, P, _, 1),
	!.

%unification choix aleatoire
unifie(P, choix_aleatoire) :-
	choix_equation_aleatoire(P,_,_,_),
	!.

unifie(P, regle):- unifie(P, rename).
unifie(P, regle):- unifie(P, simplify).
unifie(P, regle):- unifie(P, expand).
unifie(P, regle):- unifie(P, check).
unifie(P, regle):- unifie(P, orient).
unifie(P, regle):- unifie(P, decompose).
unifie(P, regle):- unifie(P, clash).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Fonction qui supprime l'equation du systeme d'equation
deleteEquation([], _, []):- !.              % si liste vide, on renvoie une liste vide
deleteEquation([Element | Tail], E, [Element| Tail2]):-
	not(Element == E),		    
	deleteEquation(Tail, E, Tail2),!.
	
deleteEquation([E | Tail], E, L):- 
	deleteEquation(Tail, E, L),!.       % on supprime l'element E de la liste

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

choix_premier(P, _, _, _):- 
	unifie(P, regle),
	!.

%%%%%%%%

choix_equation_aleatoire([],_,_,_):- !.

choix_equation_aleatoire(P,_,_,_):-
	random_member(E, P), 				% on choisit aleatoirement une equation
	deleteEquation(P, E, ListTemp),			% on supprime cette equation de la liste
	reduit_random([E|ListTemp], E, Q, regle),	% on essaie d'appliquer les transformations E, nouvelle liste = Q
	choix_equation_aleatoire(Q,_,_,_).

reduit_random(ListTemp2, E, Q, regle) :- regle(E, rename), !, reduit(rename, E, ListTemp2, Q).
reduit_random(ListTemp2, E, Q, regle) :- regle(E, simplify), !, reduit(simplify, E, ListTemp2, Q).
reduit_random(ListTemp2, E, Q, regle) :- regle(E, expand), !, reduit(expand, E, ListTemp2, Q).
reduit_random(ListTemp2, E, Q, regle) :- regle(E, check), !, reduit(check, E, ListTemp2, Q).
reduit_random(ListTemp2, E, Q, regle) :- regle(E, orient), !, reduit(orient, E, ListTemp2, Q).
reduit_random(ListTemp2, E, Q, regle) :- regle(E, decompose), !, reduit(decompose, E, ListTemp2, Q).
reduit_random(ListTemp2, E, Q, regle) :- regle(E, clash), !, reduit(clash, E, ListTemp2, Q).

%%%%%%%%

	% niveau 1: clash, check
	% niveau 2: rename, simplify
	% niveau 3: orient
	% niveau 4: decompose
	% niveau 5: expand

choix_pondere([], _, _, _):-
	true.

choix_pondere(P, [], _, 1):-		% passage au niveau 2
	choix_pondere(P, P, _, 2),
	!.

choix_pondere(P, [], _, 2):-		% passage au niveau 3
	choix_pondere(P, P, _, 3),
	!.

choix_pondere(P, [], _, 3):-		% passage au niveau 4
	choix_pondere(P, P, _, 4),
	!.

choix_pondere(P, [], _, 4):-		% passage au niveau 5
	choix_pondere(P, P, _, 5),
	!.

% on a applique toutes les regles sans succes, echec de l'unification
choix_pondere(_, [], _, 5):-
	fail,
	!.

%%%%%%%%

%%%% clash, check (niveau 1)

%clash
choix_pondere(P, [Head|_], _, 1):-
	regle(Head , clash),
	!,
 	reduit(clash, Head, P, _),
	!.

%check
choix_pondere(P, [Head|_], _, 1):-
	regle(Head, check),
	!,
	reduit(check, Head, P, _),
	!.

% regles non applicables dans le systeme d'equations
choix_pondere(P, [Head|Tail], _, 1):-
	\+regle(Head, clash),
	\+regle(Head, check),
	!,
	choix_pondere(P, Tail, _, 1),		% on essaye d'appliquer les transformations de niveau 1
	!.					% sur l'equation suivante

%%%% rename, simplify (niveau 2)

% rename
choix_pondere(P, [Head|_], _, 2):-
	regle(Head, rename),
	!,
	deleteEquation(P, Head, ListTemp),	% on supprime l'equation E du systeme d'equation
	reduit(rename, Head, [Head|ListTemp], Q),
	choix_pondere(Q, Q, _, 1),		% on applique la strategie choix_pondere sur le nouveau
	!.					% systeme d'equation

% simplify
choix_pondere(P, [Head|_], _, 2):-
	regle(Head, simplify),
	!,
	deleteEquation(P, Head, ListTemp),
	reduit(simplify, Head, [Head|ListTemp], Q),
	choix_pondere(Q, Q, _, 1),
	!.

% regles non applicables dans le systeme d'equations
choix_pondere(P, [Head|Tail], _, 2):-
	\+regle(Head, rename),
	\+regle(Head, simplify),
	!,
	choix_pondere(P, Tail, _, 2),
	!.

%%%% orient (niveau 3)

% orient
choix_pondere(P, [Head|_], _, 3):-
	regle(Head, orient),
	!,
	deleteEquation(P, Head, ListTemp),
	reduit(orient, Head, [Head|ListTemp], Q),
	choix_pondere(Q, Q, _, 1),
	!.

% regles non applicables dans le systeme d'equations
choix_pondere(P, [Head|Tail], _, 3):-
	\+regle(Head, orient),
	!,
	choix_pondere(P, Tail, _, 3),
	!.

%%%% decompose (niveau 4)

% decompose
choix_pondere(P, [Head|_], _, 4):-
	regle(Head, decompose),
	!,
	deleteEquation(P, Head, ListTemp),
	reduit(decompose, Head, [Head|ListTemp], Q),
	choix_pondere(Q, Q, _, 1),
	!.

% regles non applicables dans le systeme d'equations
choix_pondere(P, [Head|Tail], _, 4):-
	\+regle(Head, decompose),
	!,
	choix_pondere(P, Tail, _, 4),
	!.

%%%% expand (niveau 5)

% expand
choix_pondere(P, [Head|_], _, 5):-
	regle(Head, expand),
	!,
	deleteEquation(P, Head, ListTemp),
	reduit(expand, Head, [Head|ListTemp], Q),
	choix_pondere(Q, Q, _, 1),
	!.

% regles non applicables dans le systeme d'equations
choix_pondere(P, [Head|Tail], _, 5):-
	\+regle(Head, expand),
	!,
	choix_pondere(P, Tail, _, 5),
	!.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

unifie(P, rename) :- % Placer dans Q le resultat de l'unification avec la transformation rename
	P = [E |_], % Placer dans E la tete du systeme d'equation P
	regle(E, rename), % Test de l'applicabilite de la regle rename sur l'equation E
	reduit(rename, E, P, Q), % Application de la regle
	unifie(Q, regle),!. % Appel recursif sur l'unification de Q avec une nouvelle regle


unifie(P, simplify):- % Meme raisonnement que precedemment
	P = [E |_],
	regle(E, simplify),
	reduit(simplify, E, P, Q),
	unifie(Q, regle),!.

unifie(P, expand):-
	P = [E |_],
	regle(E, expand),
	reduit(expand, E, P, Q),
	unifie(Q, regle),!.

unifie(P, check):-
	P = [E |_],
	regle(E, check),
	reduit(check, E, P, Q),
	unifie(Q, regle),!.

unifie(P, orient):-
	P = [E |_],
	regle(E, orient),
	reduit(orient, E, P, Q),
	unifie(Q, regle),!.

unifie(P, decompose):-
	P = [E |_],
	regle(E, decompose),
	reduit(decompose, E, P, Q),
	unifie(Q, regle),!.

unifie(P, clash):-
	P = [E |_],
	regle(E, clash),
	reduit(clash, E, P, Q),
	unifie(Q, regle),!.


% Transformation du systeme d'equations P en un systeme d'equations Q par application de la regle de transformation a l'equation E


% reduit sur regle decompose
reduit(decompose, E, P, Q):-
	echo('\tsystem: '),echo(P),nl, % Affichage des etapes pour le trace_unif
	echo('\tdecompose: '),echo(E),nl,
	splitEquation(E,X,T), % Separe E en X et T avec comme separateur ?=
	functor(X,_,ArityX), % Recuperation de l'arite de X
	functor(T,_,_),
	P = [_|Tail], % Recup de la queue de la liste P dans Tail
	repet(X,T,ArityX,Tail,Q). % Boucle iterative pour verifier l'unification sur tous les arguments des fonctions

repet(_,_,0,T,Q):- Q = T, !. % Arret du predicat repet et affectation du resultat dans Q
repet(X,T,N,Tail,Q) :-
	N > 0, % Condition d'arret
	arg(N,X,ValX), % Recuperer l'argument a l'indice N dans X et le mettre dans ValX
	arg(N,T,ValT),
	Var = [ValX?=ValT|Tail], % Var va desormais contenir ValX ?= ValT en plus dans la liste Tail
	N1 is N - 1, % Decrementation de la boucle
	repet(X,T,N1,Var,Q).

reduit(rename, E, P, Q):-
	echo('\tsystem: '),echo(P),nl,
	echo('\trename: '),echo(E),nl,
	splitEquation(E,X,T),
	X = T,
	P = [_|Q].

reduit(simplify, E, P, Q):-
	echo('\tsystem: '),echo(P),nl,
	echo('\tsimplify: '),echo(E),nl,
	splitEquation(E,X,T),
	X = T,
	P = [_|Q].

reduit(expand, E, P, Q):-
	echo('\tsystem: '),echo(P),nl,
	echo('\texpand: '),echo(E),nl,
	splitEquation(E,X,T),
	X = T,
	P = [_|Q].

reduit(check, E, P, _):-
	echo('\tsystem: '),echo(P),nl,
	echo('\tcheck: '),echo(E),nl,
	fail,
	!.

reduit(orient, E, P, Q):-
	echo('\tsystem: '),echo(P),nl,
	echo('\torient: '),echo(E),nl,
	splitEquation(E,X,T),
	P = [_|Tail],
	Q = [T ?= X | Tail].


reduit(clash, E, P, _):-
	echo('\tsystem: '),echo(P),nl,
	echo('\tclash: '),echo(E),nl,
	fail,
	!.
\end{lstlisting}

\end{document}
