\documentclass[10pt,a4paper]{report}

\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{lipsum}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage[dvipsnames]{xcolor}
\usepackage{setspace}

\hypersetup{
	colorlinks,
	urlcolor=black
	filecolor=black,
	linkcolor=black,
	citecolor=black,
}

\definecolor{mygray}{RGB}{233,233,233}

\lstset{
	language=Prolog,
	basicstyle=\ttfamily\small,
	identifierstyle=\color{Cerulean},
	numberstyle=\color{green},
	keywordstyle=\color{blue},
	commentstyle=\it\color{green},
	stringstyle=\color{black!60},
	columns=flexible,
	tabsize=4,
	extendedchars=true,
	showspaces=false,
	showstringspaces=false,
	numbers=left,
	numberstyle=\small,
	breaklines=true,
	breakautoindent=true,
	captionpos=b,
	backgroundcolor=\color{mygray},
	captionpos = b 
}

\newcommand{\HRule}{\rule{\linewidth}{2mm}}
\newsavebox{\BBbox}
\newenvironment{DDbox}[1]{
	\begin{lrbox}{\BBbox}\begin{minipage}{\linewidth}}
		{\end{minipage}\end{lrbox}\noindent\colorbox{mygray}{\usebox{\BBbox}} \\
	[.5cm]}

\fancypagestyle{plain}{
	\fancyhf{}
	\fancyhead[L]{Soutenance}
	\fancyhead[R]{\ifnum\value{part}>0 \partname\ \thepart \fi}
	\renewcommand{\headrulewidth}{0.4pt}
	\fancyfoot[L]{Aurélien Thirion et Nicolas Blin}
	\fancyfoot[C]{\thepage}
	\fancyfoot[R]{\today}
	\renewcommand{\footrulewidth}{0.4pt}
}


\geometry{
	a4paper,
	total={210mm,297mm},
	left=20mm,
	right=20mm,
	top=20mm,
	bottom=20mm,
}

\begin{document}
\begin{titlepage}
    \begin{center}
      ~\\[4cm]
      \textsc{\huge Université de Lorraine}\\[1.0cm]
      \includegraphics{univr.jpg}\\[0.5cm]
      \textsc{\Large Faculté de Science et Technologie}\\[0.5cm]
      \textsc{\Large M1 Informatique}\\[1cm]
      \HRule \\[0.4cm]
      { \huge \bfseries Martelli Montanari \\[0.4cm] }
      \HRule \\[1cm]
     \textsc{\LARGE Algorithme d'unification \\ ~ \\ Projet de LMC }\\[4cm]
	\emph{Auteurs:}\\
	Aurélien \textsc{Thirion} \\
	Nicolas \textsc{Blin}\\
      \vfill
      {\large \today}
    \end{center}
  \end{titlepage}








\chapter*{Introduction}
Nous avons voulu, dans ce projet, essayer d'être le plus clair et simple possible en
disposant dans différents fichiers le code source de notre programme. Ainsi dans le code
principal, il y a le minimum de ligne pour comprendre réellement de processus de
l'unification de Martelli-Montanari. Notre code principal se situe dans \textbf{main.pl}, des
prédicats sont appelés lors du processus dans les fichiers suivants : \textbf{operateur.pl} ,
\textbf{predicatsRelais.pl} et \textbf{reglesTest.pl}.\\[1cm]

\begin{center}
\textbf{operateur.pl}\\
Contient l'opérateur \textbf{?=} et le code pour le echo contenu dans le mail.\\[1cm]
\textbf{predicatsRelais.pl}\\
Fonction de décomposition d'une équation E pour obtenir la partie gauche de
l'opérateur \textbf{?=} et la partie droite.\\[1cm]
\textbf{reglesTest.pl}\\
Toutes les conditions nécessaire pour appliquer la réduction (prédicat reduit(R,E,P,Q)).\\[1cm]
\end{center}





\chapter*{Question 1}
\paragraph{Mise en place pour l'unification} ~\\
On peut voir ici les instructions pour l'ouverture des différents fichiers.
\begin{lstlisting}[caption ={Dans le fichier $main.pl$}]
:-
	[operateurs],
	[predicatsRelais],
	[reglesTest].
\end{lstlisting} ~\\
Un exemple du prédicat regle(E,R) dans le code.
\begin{lstlisting}[caption ={Dans le fichier $main.pl$}]
regle(E,rename)
\end{lstlisting} ~\\
Qui va appeler le prédicat dans le fichier \textbf{reglesTest.pl}. Ici on va séparer l'équation E en les termes X et T. Il va ensuite vérifier l'applicabilité de la règle $rename$.
\begin{lstlisting}[caption ={Dans le fichier $reglesTest.pl$}]
regle(E, rename):-
	splitEquation(E,X,T),
	var(T),
	var(X).
\end{lstlisting} ~\\
Qui va appeler le prédicat dans le fichier \textbf{predicatsRelais.pl}. On récupère la partie gauche et droite de \textbf{?=} pour le mettre dans X et T respectivement.
\begin{lstlisting}[caption ={Dans le fichier $predicatsRelais.pl$}]
splitEquation(E,X,T):-
	arg(1,E,L),
	arg(2,E,R),
	X = L,
	T = R.
\end{lstlisting}

\paragraph{Occur check} ~\\
Le prédicat $occur_check$ a été assez simple à mettre en oeuvre. Il sera chargé de vérifier si V apparaît dans le terme composé T.
\begin{lstlisting}[caption ={Dans le fichier $main.pl$}]
occur_check(V,T):-
	compound(T),
	var(V),
	contains_var(V,T).
\end{lstlisting}

\paragraph{Reduit} ~\\
Voici un exemple de $reduit$ qui se charge d'appliquer la règle rename.
\begin{lstlisting}[caption ={reduit dans $main.pl$}]
reduit(rename, E, P, Q):-
	splitEquation(E,X,T),
	X = T,
	P = [_|Q].
\end{lstlisting}





\chapter*{Question 2}
\paragraph{Stratégies} ~\\
On s'intéresse désormais à la rapidité de l'exécution de l'algorithme d'unification.
Pour cela, on vas mettre en place plusieurs strarégie.
\newline
La Première stratégie consiste à choisir la première équation de la liste d'équation et d'essayer de lui appliquer une régle. Cette Stratégie correspond à la méthode de résolution qui à etait mis en place dans la question1. Elle est définit par le prédicat suivant :
\begin{lstlisting}[caption ={Stratégie choix premier dans $main.pl$}]
% unification choix premier
unifie(P, choix_premier) :- 
	choix_premier(P, _, _, _),
	!.
	
	choix_premier(P, _, _, _) :- 
	unifie(P, regle),
	!.
\end{lstlisting} ~\\

La Deuxième stratégie consiste à appliquer les régles de transformation dans un certaine ordre. On cherche à appliquer certaines régles en priorité par rapport à d'autres. On essaie ainsi d'appliquer des régles sur l'ensemble du système d'équations avant d'en essayer d'autres. En d'autres termes, on essaie de trouver dans le systèmes d'équations une équation ou l'on peut appliquer notre régle au lieu de chercher une régle à appliquer à une équation.
\newline
On définit la priorité dans laquelle appliquer les régles comme suit:

\begin{enumerate}
  \item Clash, Check
  \item Rename, Simplify
  \item Orient
  \item Decompose
  \item Expand
\end{enumerate}
Par exemple, appliqué les régles Clash et Check en priorité permet de stopper l'éxécution plus rapidement si le système d'équation n'est pas unifiable.
\newline

\paragraph{Implémentation:} ~\\

\begin{lstlisting}[caption ={Stratégie choix pondere dans $main.pl$ avec les régles de poids 1}]
% unification choix pondere
unifie(P, choix_pondere) :-
	choix_pondere(P, P, _, 1),
	!.
	
%%%% clash, check

%clash
choix_pondere(_, [Head|_], _, 1):-
	regle(Head , clash),
	!,
%	echo('\t fail clash'),
	fail,
	!.

%check
choix_pondere(_, [Head|_], _, 1):-
	regle(Head, check),
	!,
%	echo('\t fail check'),
	fail,
	!.

% regles non applicables dans le systeme d'equations
choix_pondere(P, [Head|Tail], _, 1):-
	\+regle(Head, clash),
	\+regle(Head, check),
	!,
	choix_pondere(P, Tail, _, 1),
	!.
\end{lstlisting}

\begin{lstlisting}[caption ={Stratégie choix pondere dans $main.pl$, passage aux régles de poids 1 }]
choix_pondere(P, [], _, 2):-
	choix_pondere(P, P, _, 2),
	!.
\end{lstlisting}

\paragraph{Comparaison des Stratégies:} ~\\

Grace à ces exemples, on peut constater que le choix pondere permet de remarquer rapidement si une unification est possible ou non.

\mbox{}
\newpage
\chapter*{Question 3}
\paragraph{Dans le main} ~\\
Pour le prédicat $unif$, il s'agit simplement de désativer le echo puis d'appeler le prédicat $unifie$.
\begin{lstlisting}[caption ={unif dans $main.pl$}]
unif(P,S) :-
	clr_echo,
	unifie(P,S).
\end{lstlisting} ~\\
Pour le prédicat $trace_unif$, il faut activer le echo en précisant que si l'unification marche il y aura affiché un "Yes" ou un "No" dans le cas contraire.
\begin{lstlisting}[caption ={trace unif dans $main.pl$}]
trace_unif(P,S) :-
	set_echo,
	(unifie(P,S),
	 echo('\tYes'),
	 !;
	 echo('\t'),
	 echo(P),
	 echo('\n'),
	 echo('\tNo')).
\end{lstlisting} ~\\
Une fois que ces prédcats sont fait, il suffit de mettre les echo dans le code qui sera commun aux différentes stratégies. Ainsi nous aurons par exemple dans le prédicat $reduit$ :
\begin{lstlisting}[caption ={Les echos dans $main.pl$}]
reduit(rename, E, P, Q):-
	echo('\tsystem: '),echo(P),nl,
	echo('\trename: '),echo(E),nl,
	splitEquation(E,X,T),
	X = T,
	P = [_|Q].
\end{lstlisting} ~\\






\mbox{}
\newpage
\chapter*{Code source}
\paragraph{Dans le main} ~\\
\begin{lstlisting}[caption ={$main.pl$}]
occur_check(V,T):-
	compound(T),
	var(V),
	contains_var(V,T).

unif(P,S) :-
	clr_echo,
	unifie(P,S).

trace_unif(P,S) :-
	set_echo,
	(unifie(P,S),
	 echo("Yes"),
	 !;
	 echo("No")).

unifie([], _) :- !.
unifie([]) :- !.


unifie(P):-
	unifie(P, regle),
	!.

unifie(P, regle):- unifie(P, rename).
unifie(P, regle):- unifie(P, simplify).
unifie(P, regle):- unifie(P, expand).
unifie(P, regle):- unifie(P, check).
unifie(P, regle):- unifie(P, orient).
unifie(P, regle):- unifie(P, decompose).
unifie(P, regle):- unifie(P, clash).


unifie(P, rename) :- 
	P = [E |_],
	regle(E, rename),
	reduit(rename, E, P, Q),
	unifie(Q, regle),!.


unifie(P, simplify):-
	P = [E |_],
	regle(E, simplify),
	reduit(simplify, E, P, Q),
	unifie(Q, regle),!.

unifie(P, expand):-
	P = [E |_],
	regle(E, expand),
	reduit(expand, E, P, Q),
	unifie(Q, regle),!.

unifie(P, check):-
	P = [E |_],
	regle(E, check),
	reduit(check, E, P, Q),
	unifie(Q, regle),!.

unifie(P, orient):-
	P = [E |_],
	regle(E, orient),
	reduit(orient, E, P, Q),
	unifie(Q, regle),!.

unifie(P, decompose):-
	P = [E |_],
	regle(E, decompose),
	reduit(decompose, E, P, Q),
	unifie(Q, regle),!.

unifie(P, clash):-
	P = [E |_],
	regle(E, clash),
	reduit(clash, E, P, Q),
	unifie(Q, regle),!.


reduit(decompose, E, P, Q):-
	splitEquation(E,X,T),
	functor(X,_,ArityX),
	functor(T,_,_),
	P = [_|Tail],
	repet(X,T,ArityX,Tail,Q),
	echo("decompose: "),echo(Q),nl.

repet(_,_,0,T,Q):- Q = T, !.
repet(X,T,N,Tail,Q) :-
	N > 0,
	arg(N,X,ValX),
	arg(N,T,ValT),
	Var = [ValX?=ValT|Tail],
	N1 is N - 1,
	repet(X,T,N1,Var,Q).

reduit(rename, E, P, Q):-
	splitEquation(E,X,T),
	X = T,
	P = [_|Q].

reduit(simplify, E, P, Q):-
	splitEquation(E,X,T),
	X = T,
	P = [_|Q].

reduit(expand, E, P, Q):-
	splitEquation(E,X,T),
	X = T,
	P = [_|Q].

reduit(check, _, _, _):-
	fail,
	!.

reduit(orient, E, P, Q):-
	splitEquation(E,X,T),
	P = [_|Tail],
	Q = [T ?= X | Tail].


reduit(clash, _, _, _):-
	fail,
	!.
\end{lstlisting}



\end{document}
